---
output:
  html_document:
    theme: readable
  pdf_document: default
---

```{r, echo = FALSE, message = FALSE}
library(lubridate)
date <- "02-25-2022"
weekday <- wday(mdy(date), label = TRUE, abbr = FALSE)
month <- month(mdy(date), label = TRUE)
day <- day(mdy(date))
```

---
title: `r paste(weekday, ", ", month, " ", day, sep = "")`
header-includes:
  - \usepackage{float}
  - \usepackage{booktabs}
  - \usepackage{array}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", message = FALSE, out.width = "100%", fig.align = "center", fig.width = 9, cache = FALSE, dev = ifelse(knitr::is_html_output(), "png", "pdf"))
```

```{r packages, echo = FALSE}
library(ggplot2)
library(trtools)
library(dplyr)
library(tidyr)
```

```{r utilities, echo = FALSE}
source("../../utilities.R")
```

```{r options, echo = FALSE}
options(digits = 4, width = 90)
```

`r ifelse(knitr::is_html_output(), paste("You can also download a [PDF](lecture-", date, ".pdf) copy of this lecture.", sep = ""), "")`

## The Michaelis-Menten Model

The Michaelis-Menten model is perhaps the quintessential example of an application of nonlinear regression. It is from biochemistry and concerns the relationship between the (expected) rate of an enzymatic reaction to the concentration of an enzymatic substrate (i.e., the material of the reaction). As a nonlinear regression model the Michaelis-Menten model can be written as
$$
  E(Y) = \frac{\theta_1 x}{\theta_2 + x},
$$
where $Y$ is the reaction rate and $x$ is the substrate concentration.[^1] 

The two parameters of this model, $\theta_1$ and $\theta_2$, are interpretable in terms of the relationship between the expected reaction rate and substrate concentration. The $\theta_1$ parameter is the maximum expected reaction rate (i.e., the upper asymptote as $x \rightarrow \infty$), and $\theta_2$ is the value of $x$ at which the reaction rate is half of $\theta_1$ (i.e., a "half-life" parameter) so smaller values of $\theta_2$ mean that the curve is approaching $\theta_1$ "faster" as $x$ increases.[^2] Note also that if $x = 0$ then $E(Y) = 0$ so the curve is constrained to have an "intercept" of zero, which makes sense in the context of enzyme kinetics. The plot below shows an example of the model where $\theta_1$ = 300 and $\theta_2$ = 0.5.
```{r, echo = FALSE}
library(dplyr)
library(ggplot2)
t1 <- 300
t2 <- 0.5
d <- data.frame(x = seq(0, 4, length = 100)) %>% mutate(y = t1*x/(t2 + x))
p <- ggplot(d, aes(x = x, y = y)) + theme_classic()
p <- p + geom_line()
p <- p + geom_hline(yintercept = t1, linetype = 3)
p <- p + geom_vline(xintercept = t2, linetype = 3)
p <- p + geom_hline(yintercept = t1/2, linetype = 3)
p <- p + labs(x = tex("$x$"), y = tex("$E(Y)$"))
p <- p + scale_x_continuous(breaks = sort(c(0:4, t2)), labels = c(0,tex("$\\theta_2$"),1:4)) 
p <- p + scale_y_continuous(breaks = sort(c(t1, t1/2, 0, 50, 100, 200, 250)),
   labels = c(0, 50, 100, tex("$\\theta_1/2$"), 200, 250, tex("$\\theta_1$")))
plot(p)
```
To estimate $\theta_1$ and $\theta_2$ the typical method is to conduct a series of assays, varying substrate concentration and recording the reaction rate at each concentration, and then using nonlinear regression to estimate $\theta_1$ and $\theta_2$. In the following problems you will be using data in the data frame `Puromycin`. It is included with R so there is no package to load. These data are from a study that observed reaction rates at several substrate concentrations, but also for cells that were treated with puromycin (an antibiotic). Before starting you can familiarize yourself with the data by simply typing `Puromycin` at the console prompt (it is not a large data set).

[^1]: See the Wikipedia entry on [Michaelis-Menten](https://en.wikipedia.org/wiki/Michaelis-Menten_kinetics) for details if you are interested. A related model is the [Beverton-Holt](https://en.wikipedia.org/wiki/Beverton-Holt_model) population dynamics model that is frequently used in fisheries research. 

[^2]: The interpretation of $\theta_1$ can be seen by taking the limit of $\theta_1x/(\theta_2 + x)$ as $x \rightarrow \infty$, and the interpretation of $\theta_2$ can be shown by solving $\theta_1/2 = \theta_1x/(\theta_2 + x)$ for $x$. 

1. To get started we will first ignore the experimental manipulation of treated cells with puromycin. The R code below will estimate the *linear* model $E(Y_i) = \beta_0 + \beta_1 x_i$ using `nls` and plot this model with the data.
    ```{r}
    library(ggplot2)
    m <- nls(rate ~ b0 + b1 * conc, start = c(b0 = 0, b1 = 0), data = Puromycin)

    d <- expand.grid(conc = seq(0, 1.2, length = 100), state = c("treated","untreated"))
    d$yhat <- predict(m, newdata = d)

    p <- ggplot(Puromycin, aes(x = conc, y = rate)) + 
      geom_point(aes(color = state)) + geom_line(aes(y = yhat), data = d) + 
      labs(x = "Substrate Concentration (ppm)", 
        y = "Reaction Rate (counts/min)", color = "Cell State") + 
      theme_minimal() + theme(legend.position = c(0.8,0.2))
    plot(p)
    ```
Clearly the linear model is not a good model for the data. Cut-and-paste the R code above and modify it to replace the linear model with the Michaelis-Menten model (ignoring the experimental manipulation for now). To specify starting values for $\theta_1$ and $\theta_2$, look at the plot of the data and try to guess their approximate values. Remember that $\theta_1$ is the asymptote and $\theta_2$ is the concentration at which the (expected) reaction rate is half way between zero and the asymptote. 

    **Solution**: We might estimate the nonlinear model as follows, using the figure to guess starting values for $\theta_1$ and $\theta_2$.
    ```{r}
    m <- nls(rate ~ theta1 * conc / (theta2 + conc), data = Puromycin,
      start = list(theta1 = 200, theta2 = 0.1))
    cbind(summary(m)$coefficients, confint(m))
    ```
    We can plot the model as follows by "adding" to the code above.
    ```{r}
    d <- data.frame(conc = seq(0, 1.2, length = 100))
    d$yhat <- predict(m, newdata = d)
    p <- p + geom_line(aes(y = yhat), data = d, linetype = 2)
    plot(p)
    ```


2. Now consider a linear model that will assume a linear relationship between reaction rate and concentration that is different for treated versus untreated cells (i.e., an "interaction" between substrate concentration and cell state). 
    ```{r, message = FALSE}
    m <- lm(rate ~ state + conc + conc:state, data = Puromycin)
    cbind(summary(m)$coefficients, confint(m))
    ```
From `summary` we can see that the model can be written as
$$
E(Y_i) = \beta_0 + \beta_1 d_i + \beta_2 x_i + \beta_3 d_i x_i,
$$ 
where $x_i$ represents concentration (`conc`) and $d_i$ is an indicator variable for when the treatment (`state`) is "untreated" so that
$$
  d_i = 
  \begin{cases}
    1, & \text{if the $i$-th observation is of untreated cells}, \\
    0, & \text{otherwise}.
  \end{cases}
$$
This model can be written case-wise as
$$
E(Y_i) =
\begin{cases}
  \beta_0 + \beta_2 x_i, & \text{if the $i$-th observation is of treated cells,} \\
  \beta_0 + \beta_1 + (\beta_2 + \beta_3) x_i,& \text{if the $i$-th observation is of untreated cells.}
\end{cases}
$$
We can replicate this model using the `nls` function by specifying an indicator variable in the model formula.
    ```{r}
    m <- nls(rate ~ b0 + b1*(state == "untreated") + 
      b2*conc + b3*(state == "untreated")*conc,
      data = Puromycin, start = list(b0 = 0, b1 = 0, b2 = 0, b3 = 0))
    summary(m)$coefficients
    d <- expand.grid(conc = seq(0, 1.2, length = 100), state = c("treated","untreated"))
    d$yhat <- predict(m, newdata = d)

    p <- ggplot(Puromycin, aes(x = conc, y = rate, color = state)) + 
      geom_point() + geom_line(aes(y = yhat), data = d) + 
      labs(x = "Substrate Concentration (ppm)",
        y = "Reaction Rate (counts/min)", color = "Cell State") + 
      theme_minimal() + theme(legend.position = c(0.8,0.2))
    plot(p)
    ```
Since there are only two levels of `state` we could also use the `ifelse` function to produce the same results as using the indicator variable.
    ```{r}
    m <- nls(rate ~ ifelse(state == "treated", b0 + b2*conc, b0 + b1 + (b2 + b3)*conc),
      data = Puromycin, start = list(b0 = 0, b1 = 0, b2 = 0, b3 = 0))
    summary(m)$coefficients
    ```
Obviously this is a poor model for the `Puromycin` data since expected reaction rate does not appear to be a linear function of substrate concentration. Instead we would like to have a model where there the Michaelis-Menten model describes the relationship between the expected reaction rate and substrate concentration, but *differently for each state* so that the $\theta_1$ and $\theta_2$ parameters can depend on the state. Estimate this model using the `nls` function, noting that there are many different ways that this model could be parameterized. Plot the model as well with the raw data. 

    **Solution**: Here is one way we might specify such a model. 
    ```{r}
    m1 <- nls(rate ~ ifelse(state == "treated", theta1t * conc / (theta2t + conc), 
      theta1u * conc / (theta2u + conc)), data = Puromycin,
      start = list(theta1t = 200, theta2t = 0.1, theta1u = 200, theta2u = 0.1))
    cbind(summary(m1)$coefficients, confint(m1))
    ```
    This model can be written as
    $$
    E(Y_i) = 
      \begin{cases}
      \theta_{1t}x_i/(\theta_{2t} + x_i), & \text{if the $i$-th observation is of treated cells}, \\
      \theta_{1u}x_i/(\theta_{2u} + x_i), & \text{if the $i$-th observation is of untreated cells}.
      \end{cases}
    $$
    An alternative paramterization that includes a parameter for the "effect" of treating the cells is
    $$
    E(Y_i) = 
      \begin{cases}
      (\theta_1 + \delta_1)x_i/(\theta_2 + \delta_2 + x_i), & \text{if the $i$-th observation is of treated cells}, \\
      \theta_1x_i/(\theta_2 + x_i), & \text{if the $i$-th observation is of untreated cells}.
      \end{cases}
    $$
    Note that we can establish a relationship between the parameters in the two models: $\theta_1 = \theta_{1u}$, $\theta_2 = \theta_{2u}$, $\delta_1 = \theta_{1t} - \theta_{1u}$ and $\delta_2 = \theta_{2t} - \theta_{2u}$. This latter model can be estimated as follows.
    ```{r}
    m2 <- nls(rate ~ ifelse(state == "treated", 
      (theta1 + delta1) * conc / (theta2 + delta2 + conc), 
      theta1 * conc / (theta2 + conc)), data = Puromycin,
      start = list(theta1 = 200, theta2 = 0.1, delta1 = 0, delta2 = 0))
    cbind(summary(m2)$coefficients, confint(m2))
    ```
    There are several other ways we might parameterize the model and specify it in `nls`. But for plotting purposes the parameterization does not matter.
    ```{r}
    d <- expand.grid(conc = seq(0, 1.2, length = 100), state = c("treated","untreated"))
    d$yhat <- predict(m1, newdata = d)

    p <- ggplot(Puromycin, aes(x = conc, y = rate, color = state)) +
      geom_point() + geom_line(aes(y = yhat), data = d) + 
      labs(x = "Substrate Concentration (ppm)", 
        y = "Reaction Rate (counts/min)") + 
      labs(color = "Cell State") + 
      theme_minimal() + theme(legend.position = c(0.8,0.2))
    plot(p)
    ```

0. There are several potentially useful inferences we might make here. One is the values of the two parameters for the Michaelis-Menten model *for each state*. Another is the difference in the parameters *between states*. Depending on how the model was parameterized in the previous question, some of these could be found simply by using `summary` and `confint`, while others might require using `lincon` unless the model is reparameterized. Produce estimates, standard errors, and confidence intervals for the six quantities described above.


    **Solution**: First consider inferences for the two parameters of the Micahelis-Menten model for each treatment condition. These are the parameters of the first parameterization used above.
    ```{r}
    cbind(summary(m1)$coefficients, confint(m1))
    ```
    If we were using the second parameterization, we could obtain estimates of the parameters from the untreated cells from `summary` and `confint`, but would have to use something like `lincon` to to estimate a function of the model parameters. Recall the relationships between the parameters in the two models: $\theta_1 = \theta_{1u}$, $\theta_2 = \theta_{2u}$, $\delta_1 = \theta_{1t} - \theta_{1u}$ and $\delta_2 = \theta_{2t} - \theta_{2u}$. Thus $\theta_{1t} = \theta_1 + \delta$ and $\theta_{2t} = \theta_2 + \delta_2$.
    ```{r}
    cbind(summary(m2)$coefficients, confint(m2))
    lincon(m2, a = c(1, 0, 1, 0)) # theta1t = theta1 + delta1
    lincon(m2, a = c(0, 1, 0, 1)) # theta2t = theta2 + delta2
    ```
    Now if we want to estimate the difference in the parameters of the Michaelis-Menten model between the treated and untreated states, we could get that from the second parameterization because those differences are $\delta_1$ and $\delta_2$. 
    ```{r}
    cbind(summary(m2)$coefficients, confint(m2))
    ```
    But if we were using the first parameterization we would again need to use something like `lincon` since $\delta_1 = \theta_{1t} - \theta_{1u}$ and $\delta_2 = \theta_{2t} - \theta_{2u}$.
    ```{r}
    lincon(m1, a = c(1,0,-1,0)) # delta1 = theta1t - theta1u
    lincon(m1, a = c(0,1,0,-1)) # delta2 = theta2t - theta2u
    ```
    Note that when estimating the same quantity we obtain the same estimates and standard errors from either parameterization from `summary` and `lincon`. The confidence intervals, however, are slightly different because `confint` and `lincon` use different methods of obtaining approximate confidence intervals. 
## Heteroscedasticity in the Daphnia Data

An example from [you first homework assignment](hw1-solutions.html) featured data from a survey of water fleas where the number of water fleas were counted in one liter samples of water taken from three different layers of a lake.
```{r}
library(trtools) # for daphniastrat
library(ggplot2) 
p <- ggplot(daphniastrat, aes(x = layer, y = count)) + 
  geom_dotplot(binaxis = "y", binwidth = 1, stackdir = "center") + 
  labs(x = "Layer", y = "Number of Daphnia") + theme_minimal()
plot(p)
```
We used the following linear model for these data.
```{r}
m <- lm(count ~ layer, data = daphniastrat)
summary(m)$coefficients
``` 
But heteroscedasticity is evident in the plot of the raw data above and also in a plot of the studentized residuals.
```{r}
daphniastrat$yhat <- predict(m)
daphniastrat$rest <- rstudent(m)
p <- ggplot(daphniastrat, aes(x = yhat, y = rest, color = layer)) + 
  geom_count() + theme_minimal() + 
  labs(x = "Predicted Value", y = "Studentized Residual", color = "Layer")
plot(p)
```
Note that `geom_count` is a variant of `geom_point` that makes the point size proportional to the number of points at a particular position, which is useful here. 

Heteroscedasticty is quite common when the response variable is a count. Typically the variance of the counts increases with the expected count. Here we will consider a couple of ways of dealing with this heteroscedasticty.

1. We might assume that the variance varies by layer with the expected count, so that 
$$
  \text{Var}(Y_i) = 
  \begin{cases}
    \sigma_e^2, & \text{if the $i$-th observation is from the epilimnion layer}, \\
    \sigma_t^2, & \text{if the $i$-th observation is from the thermocline layer}, \\
    \sigma_h^2, & \text{if the $i$-th observation is from the hypolimnion layer}.
  \end{cases}
$$
If so, then our weights should be specified such that
$$
  w_i \propto 
  \begin{cases}
    1/\sigma_e^2, & \text{if the $i$-th observation is from the epilimnion layer}, \\
    1/\sigma_t^2, & \text{if the $i$-th observation is from the thermocline layer}, \\
    1/\sigma_h^2, & \text{if the $i$-th observation is from the hypolimnion layer}.
  \end{cases}
$$
We do not know $\sigma_e^2$, $\sigma_t^2$, and $\sigma_h^2$, but they could be *estimated* using the sample variances $s_e^2$, $s_t^2$, and $s_h^2$, respectively, which we can easily compute since we have multiple observations from each layer. Estimate the model using weighted least squares with weights computed as described above. The sample standard deviations can be computed and used to add weights to the data frame using functions from the **dplyr** package as demonstrated with the `CancerSurvival` data in lecture on [February 18th](lecture-02-18-2022.html).

    **Solution**: First we compute the weights using functions from the **dplyr** package.
    ```{r}
    library(dplyr)
    daphniastrat <- daphniastrat %>% group_by(layer) %>% mutate(w = 1 / var(count))
    ```
    Then we estimate the model using weighted least squares.
    ```{r}
    m <- lm(count ~ layer, data = daphniastrat, weights = w)
    summary(m)$coefficients
    ```

2. Assuming again that the variance of the counts vary by layer so that
$$
  \text{Var}(Y_i) = 
  \begin{cases}
    \sigma_e^2, & \text{if the $i$-th observation is from the epilimnion layer}, \\
    \sigma_t^2, & \text{if the $i$-th observation is from the thermocline layer}, \\
    \sigma_h^2, & \text{if the $i$-th observation is from the hypolimnion layer},
  \end{cases}
$$
another approach would be to use a *parametric model* that estimates the usual parameters of the regression model (i.e., $\beta_0$, $\beta_1$, and $\beta_3$) and the three variances above *simultaneously*. Do this using the `gls` function from the **nlme** package as demonstrated in lecture on [February 23rd](lecture-02-23-2022.html).

    **Solution**: Here is how we would estimate this model.
    ```{r}
    library(nlme) # for gls function
    m <- gls(count ~ layer, data = daphniastrat, 
      weights = varIdent(form = ~ 1 | layer), method = "ML")
    summary(m)
    ```
    The model above was estimated using *maximum likelihood* (ML). But another method is to use what is called *restricted maximum likelihood* (REML) which is the default method. It is interesting to note that for this model, this REML effectively equivalent to the approach used in the previous problem.
    ```{r}
    library(nlme) # for gls function
    m <- gls(count ~ layer, data = daphniastrat, 
      weights = varIdent(form = ~ 1 | layer), method = "ML")
    summary(m) 
    ```
    We will discuss maximum likelihood and perhaps restricted maximum likelihood later in the course.

3. With counts it is often assumed that the variance is proportional to the expected response --- i.e., $\text{Var}(Y_i) \propto E(Y_i)$. Assuming that is true here, estimate the model using *iteratively weighted least squares* as was demonstrated in lecture on [February 23rd](lecture-02-23-2022.html). 

    **Solution**: We can program the iteratively weighted least squares algorithm as follows.
    ```{r}
    daphniastrat$w <- 1
    for (i in 1:5) {
      m <- lm(count ~ layer, data = daphniastrat, weights = w)
      print(coef(m))
      daphniastrat$w <- 1 / predict(m)
    }
    summary(m)
    ```
    Note how the estimates do not change. For this particular model the algorithm only needs to go through one iteration to compute the weights. This is because the predicted values do not depend on the weights in this particular model. 


