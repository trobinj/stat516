---
output:
  html_document: 
    theme: readable
  pdf_document: default
---

```{r, echo = FALSE, message = FALSE}
library(lubridate)
date <- "02-09-2024"
weekday <- wday(mdy(date), label = TRUE, abbr = FALSE)
month <- month(mdy(date), label = TRUE)
day <- day(mdy(date))
```

---
title: `r paste(weekday, ", ", month, " ", day, sep = "")`
header-includes:
  - \usepackage{float}
  - \usepackage{booktabs}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(comment = "", echo = TRUE, message = FALSE, out.width = "100%", fig.align = "center", cache = FALSE, dev = ifelse(knitr::is_html_output(), "png", "pdf"))
```

```{r packages, echo = FALSE}
library(tidyverse)
suppressWarnings(library(kableExtra))
```

```{r utilities, echo = FALSE}
source("../../utilities.R")
```

```{r options, echo = FALSE}
options(digits = 4)
```

`r ifelse(knitr::is_html_output(), paste("You can also download a [PDF](lecture-", date, ".pdf) copy of this lecture.", sep = ""), "")`

## The Von Bertalanffy Growth Model

Consider the data frame `walleye` from the package **alr4**.
```{r}
library(alr4)
head(walleye)
```
The `period` variable refers to three distinct management periods: pre 1990, 1991-1996, and 1997-2000. It will be useful to explicitly define that as a categorical variable (i.e., a `factor` in R) with descriptive category labels.
```{r}
walleye$periodf <- factor(walleye$period, levels = c(1,2,3),
  labels = c("pre-1991","1991-1996","1997-2000"))
head(walleye)
```
Let's visualize the data.
```{r}
p <- ggplot(walleye, aes(y = length, x = age)) + facet_wrap(~ periodf) + 
  theme_minimal() + geom_point(alpha = 0.25, size = 0.5) +
  labs(x = "Age (years)", y = "Length (mm)",
   title = "Length and Age of Walleye During Three Management Periods",
   subtitle = "Butternut Lake, Wisconsin",
   caption = "Source: Weisberg, S. (2014). Applied Linear Regression, 4th edition. Hoboken, NJ: Wiley.")
plot(p)
```
A common nonlinear regression model for these kind of data is the Von Bertalanffy growth model. This model can be written many different ways. One that is similar to the exponential model we used earlier is
$$
  E(L) = \alpha + (\delta - \alpha)2^{-a/\gamma},
$$
where $L$ and $a$ are length and age, respectively. The parameters can be interpreted as follows.

1. $\alpha$ is the asymptote of $E(L)$ as $a$ increases.
0. $\delta$ is the value of $E(L)$ when $a$ = 0.
0. $\gamma$ is the value of $a$ at which $E(L)$ is half way between $\delta$ and $\alpha$.

It is worth noting that this is *not* the parameterization of the model that is usually used in fisheries research. The parameterization I have used here is more closely related to the exponential model we considered for the `ToothGrowth` data. 

Consider first a model in which there are no differences in the function between management periods. The starting values were obtained by "eyeballing" the plot. 
```{r}
m <- nls(length ~ alpha + (delta - alpha) * 2^(-age / gamma), 
   data = walleye, start = list(alpha = 500, delta = 200, gamma = 5))
cbind(summary(m)$coefficients, confint(m))
```
Now suppose we want to allow the $\alpha$ and $\gamma$ parameters to vary over management periods, but not $\delta$. The model we want could be written case-wise as 
$$
  E(L_i) = 
  \begin{cases}
    \alpha_1 + (\delta - \alpha_1)2^{-a_i/\gamma_1}, & \text{if the $i$-th observation is from the first period}, \\
    \alpha_2 + (\delta - \alpha_2)2^{-a_i/\gamma_2}, & \text{if the $i$-th observation is from the second period}, \\
    \alpha_3 + (\delta - \alpha_3)2^{-a_i/\gamma_3}, & \text{if the $i$-th observation is from the third period}.
  \end{cases}
$$
Perhaps the easiest way to specify this model is to use the `case_when` function from the **dplyr** package.
```{r}
library(dplyr)
m <- nls(length ~ case_when(
  periodf == "pre-1991"  ~ alpha1 + (delta - alpha1) * 2^(-age / gamma1),
  periodf == "1991-1996" ~ alpha2 + (delta - alpha2) * 2^(-age / gamma2),
  periodf == "1997-2000" ~ alpha3 + (delta - alpha3) * 2^(-age / gamma3)
  ), start = list(alpha1 = 500, alpha2 = 500, alpha3 = 500,
    delta = 200, gamma1 = 5, gamma2 = 5, gamma3 = 5), data = walleye)
cbind(summary(m)$coefficients, confint(m))
d <- expand.grid(age = seq(0, 11, length = 100), 
   periodf = levels(walleye$periodf))
d$yhat <- predict(m, newdata = d)

p <- ggplot(walleye, aes(y = length, x = age)) + facet_wrap(~ periodf) + 
  theme_minimal() + geom_point(alpha = 0.25, size = 0.5) + 
  geom_line(aes(y = yhat), data = d) + 
  labs(x = "Age (years)", y = "Length (mm)",
   title = "Length and Age of Walleye During Three Management Periods",
   subtitle = "Butternut Lake, Wisconsin",
   caption = "Source: Weisberg, S. (2014). Applied Linear Regression, 4th edition. Hoboken, NJ: Wiley.")
plot(p)
```
Here `summary` and `confint` provide inferences for each parameter in each period, but do not provide inferences about the *differences* in the parameters *between* periods. But we can use `lincon` to do this. Suppose we wanted to compare the second and third periods with the first.
```{r}
library(trtools) # for lincon
lincon(m, a = c(-1,1,0,0,0,0,0)) # alpha2 - alpha1
lincon(m, a = c(-1,0,1,0,0,0,0)) # alpha3 - alpha1
lincon(m, a = c(0,0,0,0,-1,1,0)) # gamma2 - gamma1
lincon(m, a = c(0,0,0,0,-1,0,1)) # gamma3 - gamma1
```
Sometimes it is helpful to write the model as a *function* to keep the code tidy. We can program the function 
$$
  f(a) = \alpha + (\delta - \alpha)2^{-a/\gamma}
$$
as follows.
```{r}
vbf <- function(age, alpha, delta, gamma) {
  alpha + (delta - alpha) * 2^(-age / gamma)
}
```
Now we can use `vbf` in `nls`. 
```{r}
m <- nls(length ~ case_when(
  periodf == "pre-1991"  ~ vbf(age, alpha1, delta, gamma1),
  periodf == "1991-1996" ~ vbf(age, alpha2, delta, gamma2),
  periodf == "1997-2000" ~ vbf(age, alpha3, delta, gamma3)
  ), start = list(alpha1 = 500, alpha2 = 500, alpha3 = 500,
    delta = 200, gamma1 = 5, gamma2 = 5, gamma3 = 5), data = walleye)
cbind(summary(m)$coefficients, confint(m))
```

## Segmented Regression as a Linear Model

Consider data from a study of the effect of attractant age on attracting fire ants.
```{r}
library(trtools) # for fireants data
p <- ggplot(fireants, aes(x = day, y = count, color = group)) + 
  geom_point(alpha = 0.5) + theme_minimal() + 
  theme(legend.position = c(0.8,0.8)) + 
  labs(x = "Age of Attractant (Days)", y = "Number of Ants Trapped",
   color = "Group")
plot(p)
```
Consider first this model for only the treatment group:
$$
	E(Y_i) = \beta_0 + \beta_1 x_i + \beta_2 \mathbf{1}(x_i < \delta)(x_i - \delta),
$$
where $Y_i$ and $x_i$ are the fire ant count and age of attractant, respectively, and $\mathbf{1}$ is an *indicator function* defined as
$$
	\mathbf{1}(x_i < \delta) = 
	\begin{cases}
	 	1, & \text{if $x_i < \delta$}, \\
	 	0, & \text{if $x_i \ge \delta$.}
	\end{cases}
$$
In general, an [indicator function](https://en.wikipedia.org/wiki/Indicator_function) is a function such that 
$$
  \mathbf{1}(\text{statement}) = 
  \begin{cases}
    1, & \text{if the statement is true}, \\
    0, & \text{if the statement is false}.
  \end{cases}
$$
Writing the model case-wise for $x_i < \delta$ versus $x_i \ge \delta$ we have
$$
	E(Y_i) = 
	\begin{cases}
		\beta_0 - \beta_2 \delta + (\beta_1 + \beta_2)x_i, & \text{if $x_i < \delta$,} \\
		\beta_0 + \beta_1 x_i, & \text{if $x_i \ge \delta$.}
	\end{cases}
$$
This is sometimes called *segmented*, *piece-wise*, or *broken-stick* regression. It is also a special case of a *spline*. The $\delta$ is called a "knot" of the spline. If the knot is known then this is a *linear* model. 
```{r}
treated <- subset(fireants, group == "Treatment")
m <- lm(count ~ day + I((day < 40)*(day - 40)), data = treated)
summary(m)$coefficients
```
Note that we can write the indicator function $\mathbf{1}(x_i < 40)$ as `(day < 40)` in R.
```{r}
d <- expand.grid(day = seq(0, 60, length = 100), group = "Treatment")
d$yhat <- predict(m, newdata = d)
p <- p + geom_line(aes(y = yhat), data = d)
plot(p)
```
Now it would be useful to extend the model to include the control group, but subject to a couple of constraints:

1. The relationship between expected count and age for the *control* group should not have a break (because there is no attractant to wear off).

2. After 40 days the relationship between expected count and age should be *identical* for the control and treatment groups (because the attractant has worn off).

Here's a model that will accomplish that:
$$
	E(Y_i) = \beta_0 + \beta_1 x_i + \beta_2 \mathbf{1}(x_i < \delta)(x_i - \delta)g_i,
$$
where 
$$
  g_i = 
  \begin{cases}
    1, & \text{if the $i$-th observation is from the treatment group}, \\
    0, & \text{otherwise},
  \end{cases}
$$
so that the model can be written as
$$
  E(Y_i) = 
	\begin{cases}
		\beta_0 - \beta_2 \delta + (\beta_1 + \beta_2)x_i, 
		  & \text{if the $i$-th observation is from the treatmnt group and $x_i < \delta$}, \\
		\beta_0 + \beta_1 x_i, & \text{otherwise}. 
	\end{cases}
$$
```{r}
m <- lm(count ~ day + I((day < 40)*(day - 40)*(group == "Treatment")), 
   data = fireants)

d <- expand.grid(day = seq(0, 60, length = 100),
   group = c("Control","Treatment"))
d$yhat <- predict(m, newdata = d)

p <- ggplot(fireants, aes(x = day, y = count, color = group)) + 
  geom_point(alpha = 0.5) + theme_minimal() + 
  theme(legend.position = c(0.8,0.8)) + 
  labs(x = "Age of Attractant (Days)",
   y = "Number of Ants Trapped", color = "Group") + 
  geom_line(aes(y = yhat), data = d)
plot(p)
```
Now we can make some inferences.
```{r}
# expected counts at day 0
contrast(m, a = list(group = c("Control","Treatment"), day = 0), 
  cnames = c("Control","Treatment"))
# expected counts at day 40
contrast(m, a = list(group = c("Control","Treatment"), day = 40), 
  cnames = c("Control","Treatment"))
# slopes before day 40
contrast(m,
  a = list(group = c("Control","Treatment"), day = 1),
  b = list(group = c("Control","Treatment"), day = 0),
  cnames = c("Control","Treatment"))
# slopes after day 40
contrast(m,
  a = list(group = c("Control","Treatment"), day = 41),
  b = list(group = c("Control","Treatment"), day = 40),
  cnames = c("Control","Treatment"))
# difference in expected counts at day 20
contrast(m,
  a = list(group = "Treatment", day = 20),
  b = list(group = "Control", day = 20))
```
We could go one step further by assuming that for the control group and after the knot the expected count is constant. This would require us to drop the term $\beta_1x_i$.
```{r}
m <- lm(count ~ I((day < 40) * (day - 40) * 
   (group == "Treatment")), data = fireants)

d <- expand.grid(day = seq(0, 60, length = 100), 
   group = c("Control","Treatment"))
d$yhat <- predict(m, newdata = d)

p <- ggplot(fireants, aes(x = day, y = count, color = group)) +
  geom_point(alpha = 0.5) + theme_minimal() + 
  theme(legend.position = c(0.8,0.8)) + 
  labs(x = "Age of Attractant (Days)",
    y = "Number of Ants Trapped", color = "Group") + 
  geom_line(aes(y = yhat), data = d)
plot(p)
```
Now consider the following inferences.
```{r}
# slopes before day 40
contrast(m,
  a = list(group = c("Control","Treatment"), day = 1),
  b = list(group = c("Control","Treatment"), day = 0),
  cnames = c("Control","Treatment"))
# slopes after day 40
contrast(m,
  a = list(group = c("Control","Treatment"), day = 41),
  b = list(group = c("Control","Treatment"), day = 40),
  cnames = c("Control","Treatment")) # slopes after day 40
```

## Segmented Regression as a Nonlinear Model

If the knot $\delta$ is *known* then the model is *linear*. We can write
$$
	E(Y_i) = \beta_0 + \beta_1 x_i + \beta_2 \mathbf{1}(x_i < \delta)(x_i - \delta)g_i
$$
as 
$$
  E(Y_i) = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2},
$$
where $x_{i1} = x_i$ (day) and $x_{i2} = \mathbf{1}(x_i < \delta)(x_i - \delta)g_i$, provided we *know* $\delta$. But what if $\delta$ is unknown and is to be estimated? Then we have a *nonlinear* model.

Let's start estimating a *linear* model with `nls` by guessing the value of $\delta$. This will give us some good starting values.
```{r}
m <- nls(count ~ b0 + b1 * day + b2 * (day < 40) * (day - 40) * 
   (group == "Treatment"), data = fireants, 
   start = list(b0 = 0, b1 = 1, b2 = 1))
cbind(summary(m)$coefficients, confint(m))
```
Now consider a model where the knot ($\delta$) is a *parameter*, using the estimate from the linear model as starting values. 
```{r}
m <- nls(count ~ b0 + b1 * day + b2 * (day < delta) * (day - delta) *
   (group == "Treatment"), data = fireants, 
   start = list(b0 = 10, b1 = 0, b2 = -1, delta = 40))
cbind(summary(m)$coefficients, confint(m))
```
We can use `lincon` provided that the quantity of interest is a linear combination of parameters. For example, recall that the model can be written as
$$
  E(Y_i) = 
	\begin{cases}
		\beta_0 - \beta_2 \delta + (\beta_1 + \beta_2)x_i, 
		  & \text{if $x_i < \delta$ and treatment}, \\
		\beta_0 + \beta_1 x_i, & \text{otherwise}, 
	\end{cases}
$$
so the slope before the knot for the treatment group is $\beta_1 + \beta_2$. This can be written as 
$$
  \ell = a_0\beta_0 + a_1\beta_1 + a_2\beta_2 + a_3\delta + b
$$
where $a_0 = 0$, $a_1 = 1$, $a_2 = 1$, $a_3 = 0$, and $b = 0$.
```{r}
# slope before knot for treatment group
lincon(m, a = c(0, 1, 1, 0))
```

## Bent Cable Regression

The data frame `children` in the package **npregfast** contains 2500 observations of the age and height of children. 
```{r, fig.height = 6}
library(ggplot2)
library(npregfast)
p <- ggplot(children, aes(x = age, y = height, color = sex)) + 
  geom_point(alpha = 0.25) + theme_minimal() + 
  labs(x = "Age (years)", y = "Height (cm)", color = "Gender") + 
  theme(legend.position = c(0.9,0.2))
plot(p)
```
The "bent cable" regression model can be used as kind of crude growth model for these data. It can be viewed as a generalization of the segmented regression model where rather than having two lines meet at a sharp angle, one line gradually transitions into the other by attaching them by what looks like a bent cable. The figure below shows a bent cable model. 
```{r, echo = FALSE, fig.height = 5}
b0 <- 6
b1 <- 1
b2 <- -1.25
delta <- 5
gamma <- 3

q <- function(x, delta, gamma) {
  (x - delta + gamma)^2/(4 * gamma) * (abs(x - delta) <= gamma) + 
    (x > (delta + gamma)) * (x - delta)
}

d <- data.frame(x = seq(delta - 6, delta + 6, length = 1000)) %>% 
  mutate(y1 = b0 + b1*x + b2*q(x, delta, gamma)) %>% 
  mutate(y2 = b0 + b1*x + b2*q(x, delta, 0.0001))

p <- ggplot(d, aes(x = x, y = y1)) + theme_minimal()
p <- p + geom_line(aes(y = y2), alpha = 0.25) + geom_line()
p <- p + geom_vline(xintercept = c(delta, delta + gamma, delta - gamma), linetype = 3)
p <- p + scale_x_continuous(breaks = c(delta - gamma, delta, delta + gamma),
  labels = c(tex("$\\delta - \\gamma$"), tex("$\\delta$"), tex("$\\delta + \\gamma$")))
p <- p + scale_y_continuous(labels = NULL)
p <- p + labs(x = tex("$x$"), y = tex("$E(Y)$"))
p <- p + theme(axis.text = element_text(color = "black", size = 10))
plot(p)
```
The grey lines show a segmented regression model while the solid curve shows a bent cable model. Essentially there are two lines: one line to the left of $\delta - \gamma$ and one line to the right of $\delta + \gamma$. And between the two lines (i.e., between $\delta - \gamma$ and $\delta + \gamma$) is a quadratic polynomial that joins the two lines in such a way that the whole piece-wise function is smooth. The parameter $\delta$ represents the point at which the two lines would meet if there was no bend, and $\gamma$ is the half of the distance between the points $\delta - \gamma$ and $\delta + \gamma$. As $\gamma$ gets closer to zero this function approaches a segmented regression model (as shown by the grey lines).

The bent cable regression model can be written as
$$
  E(Y) = \beta_0 + \beta_1 x + \beta_2 q(x, \delta, \gamma),
$$
where $q(x, \delta, \gamma)$ is a function defined as
$$
	q(x, \delta, \gamma) = \frac{(x - \delta + \gamma)^2}{4\gamma}
	\mathbf{1}(\delta - \gamma \le x \le \delta + \gamma) + \mathbf{1}(x > \delta + \gamma)(x - \delta).
$$
This can be written case-wise as
$$
E(Y) = 
\begin{cases}
\beta_0 + \beta_1 x,             & \text{if $x < \delta - \gamma$}, \\
\beta_0 + \beta_1 x + \beta_2\frac{(x_i - \delta + \gamma)^2}{4\gamma}, & \text{if $\delta - \gamma \le x \le \delta + \gamma$}, \\
\beta_0 - \delta\beta_2 + (\beta_1 + \beta_2) x, & \text{if $x > \delta + \gamma$}.
\end{cases}
$$
So when $x < \delta - \gamma$ we have a line with intercept $\beta_0$ and slope $\beta_1$, and after $x > \delta + \gamma$ we have another line with intercept $\beta_0 - \delta\beta_2$ and slope $\beta_1 + \beta_2$. Between $\delta - \gamma$ and $\delta + \gamma$ is what is basically a quadratic regression model. And all three functions are constrained so that they form one smooth and continuous function.

Given the complexity of the function $q(x,\delta,\gamma)$, it is useful to program it.
```{r}
q <- function(x, delta, gamma) {
  (x - delta + gamma)^2 / (4 * gamma) * 
    (delta - gamma <= x & x <= delta + gamma) + 
    (x > (delta + gamma)) * (x - delta)
}
```
First I will estimate a *linear* model with crude guesses of $\delta$ and $\gamma$.
```{r}
m <- nls(height ~ b0 + b1 * age + b2 * q(age, 15, 1), data = children,
   start = list(b0 = 0, b1 = 0, b2 = 0))
   summary(m)$coefficients
```
Next we can use the estimates of $\beta_0$, $\beta_1$, and $\beta_2$ as starting values in a nonlinear model.
```{r}
m <- nls(height ~ b0 + b1 * age + b2 * q(age, delta, gamma), data = children,
   start = list(b0 = 85, b1 = 5.3, b2 = -5, delta = 15, gamma = 1))
summary(m)$coefficients
```
The slope after the bend is $\beta_1 + \beta_2$, but if $\beta_2 = -\beta_1$ then the slope after the bend would be zero. This model would then be 
$$
  E(Y) = \beta_0 + \beta_1 x - \beta_1 q(x, \delta, \gamma).
$$
Let's consider using this model but now with a separate growth curve for males and females.
```{r}
m <- nls(height ~ case_when(
   sex == "male"   ~ b0m + b1m*age - b1m*q(age, deltam, gammam),
   sex == "female" ~ b0f + b1f*age - b1f*q(age, deltaf, gammaf)), 
   data = children, start = list(b0m = 86, b0f = 86, b1m = 5, b1f = 5, 
   deltam = 15, deltaf = 15, gammam = 1.5, gammaf = 1.5))
summary(m)$coefficients
d <- expand.grid(sex = c("male","female"), age = seq(5, 20, length = 200))
d$yhat <- predict(m, newdata = d)
  
p <- ggplot(children, aes(x = age, y = height, color = sex)) + 
  geom_point(alpha = 0.125) + theme_minimal() + 
  geom_line(aes(y = yhat), data = d) + 
  labs(x = "Age (years)", y = "Height (cm)", color = "Gender") +
  theme(legend.position = c(0.9,0.2))
plot(p)
```

